# Rollup 插件开发

- 插件概述
- 一个简单的例子
- 官方约定
- Properties
- Build Hooks
  - buildEnd
  - buildStart
  - closeWatcher
  - load
  - moduleParsed
  - options
  - resolveDynamicImport
  - resolveId
  - shouldTransformCachedModule
  - transform
  - watchChange
- Output Generation Hooks
  - augmentChunkHash
  - banner
  - closeBundle
  - footer
  - generateBundle
  - intro
  - outputOptions
  - outro
  - renderChunk
  - renderDynamicImport
  - renderError
  - renderStart
  - resolveFileUrl
  - resolveImportMeta
  - writeBundle
- Plugin Context
  - this.addWatchFile
  - this.emitFile
  - this.error
  - this.getCombinedSourcemap
  - this.getFileName
  - this.getModuleIds
  - this.getModuleInfo
  - this.getWatchFiles
  - this.load
  - this.meta
  - this.parse
  - this.resolve
  - this.setAssetSource
  - this.warn

# rollup 插件概述

Rollup 插件是由 [properties](https://rollupjs.org/guide/en/#properties), [build hooks](https://rollupjs.org/guide/en/#build-hooks), 以及 [output generation hooks](https://rollupjs.org/guide/en/#output-generation-hooks) 三部分组成。插件应该遵循官方约定，它应该作为一个包发布，它导出一个可以使用插件特定选项调用的函数并返回一个对象。

插件允许您自定义 Rollup 的行为，例如，在打包之前转译代码，或在 <font color=#aa1e1e>node_modules</font> 文件夹中查找第三方模块。有关如何使用它们的示例，请参阅[使用插件](https://rollupjs.org/guide/en/#using-plugins)。

更多插件的使用请参考[插件列表](https://github.com/rollup/awesome)。

# 一个简单的例子

以下插件将在不访问文件系统的情况下拦截 <font color=#aa1e1e>virtual-module（虚拟模块）</font> 的任何导入。例如，如果你需要在浏览器中使用 Rollup。它甚至可用于替换入口点，如示例中所示。

```js
// rollup-plugin-my-example.js
export default function myExample () {
  return {
    name: 'my-example', // this name will show up in warnings and errors
    resolveId ( source ) {
      if (source === 'virtual-module') {
        return source; // this signals that rollup should not ask other plugins or check the file system to find this id
      }
      return null; // other ids should be handled as usually
    },
    load ( id ) {
      if (id === 'virtual-module') {
        return 'export default "This is virtual!"'; // the source code for "virtual-module"
      }
      return null; // other ids should be handled as usually
    }
  };
}

// rollup.config.js
import myExample from './rollup-plugin-my-example.js';
export default ({
  input: 'virtual-module', // resolved by our plugin
  plugins: [myExample()],
  output: [{
    file: 'bundle.js',
    format: 'es'
  }]
});
```

# 官方对于插件的一些约定

1. 插件名字最好带上 “rollup-plugin-” 前缀。
2. 在 package.json 文件中应该包含 “rollup-plugin” 关键字。
3. 你的插件应该进行测试。我们建议使用 [mocha](https://github.com/mochajs/mocha) 或者 [ava](https://github.com/avajs/ava) 这类支持 promises 的库。
4. 尽可能使用异步方法。
5. 使用英文编写插件文档
6. 如果合适的话，确保你的插件输出正确的 sourcemap
7. 如果你的插件使用 'virtual modules'（比如：helper functions），请在模块名加上 “\0” 前缀。这样做可以阻止其他插件执行它。

# hooks 介绍

rollup Hooks 分为两类：<font color=#aa1e1e>Build Hooks</font> 和 <font color=#aa1e1e>Output Generation Hooks</font>

为了与构建过程交互，您的插件对象应该包含 "hooks"，后面称其为 "钩子"。钩子是在构建的各个阶段调用的函数。钩子可以影响构建的运行方式、提供有关构建的信息或在完成后修改构建。有如下不同种类的钩子：

- <font color=#aa1e1e>async</font>：这类钩子可以返回解析为相同类型值的 Promise; 否则，钩子将标记为 sync。
- <font color=#aa1e1e>first</font>：如果多个插件实现了这个钩子，钩子将按顺序运行，直到钩子返回 null 或 undefined。
- <font color=#aa1e1e>sequential</font>：如果多个插件实现了此钩子，它们都将按照指定的插件顺序运行。如果一个钩子是异步的，这种类型的后续钩子将一直等待，直到当前钩子被解析。
- <font color=#aa1e1e>parallel</font>：如果多个插件实现了这个钩子，它们都将按照指定的插件顺序运行。如果一个钩子是异步的，则此类后续钩子将并行运行，而不是等待当前钩子。


钩子既可以是对象，也可以是函数。**如果是对象情况下，必须将 handler 写成函数的形式。**并且你还可以提供两个属性 <font color=#aa1e1e>order</font> 和 <font color=#aa1e1e>sequential</font>：

- order: "pre" | "post" | null
  - order："pre" 选项值表示请先运行此插件。
  - order："post" 选项值表示请最后一个运行此插件。
  - order：null 表示在用户指定的位置运行。

```js
export default function resolveFirst() {
  return {
    name: 'resolve-first',
    resolveId: {
      order: 'pre',
      handler(source) {
        if (source === 'external') {
          return { id: source, external: true };
        }
        return null;
      }
    }
  };
}
```
如果多个插件使用 “pre” 或 “post”，则 Rollup 将按用户指定的顺序运行它们。此选项可用于所有插件钩子。对于并行钩子，它会更改钩子的同步部分的运行顺序。

- sequential: boolean

不要将此钩子与其他插件的相同钩子并行运行。只能用于 parallel 钩子。使用此选项将使 Rollup 等待所有先前插件的结果，然后执行插件钩子，然后再次并行运行剩余的插件。例如，当你有插件A，B，C，D，E都实现相同的 parallel 钩子并且中间插件 C 的 sequential 设置为 true 时，那么 Rollup 将首先并行运行A + B，然后是 C 本身，最后是 D + E 并行运行。

当您需要在相互依赖的不同 [writeBundle](https://rollupjs.org/guide/en/#writebundle) 钩子中运行多个命令行工具时，您可以将此选项与 order 选项结合使用来达到指定的执行顺序。

```js
import { resolve } from 'node:path';
import { readdir } from 'node:fs/promises';

export default function getFilesOnDisk() {
  return {
    name: 'getFilesOnDisk',
    writeBundle: {
      sequential: true,
      order: 'post',
      async handler({ dir }) {
        const topLevelFiles = await readdir(resolve(dir));
        console.log(topLevelFiles);
      }
    }
  };
}
```

## Build Hooks

<font color=#aa1e1e>Build Hooks</font>在构建阶段运行，该阶段由 <font color=#aa1e1e>rollup.rollup(inputOptions)</font> 触发。它们主要关注在 Rollup 处理输入文件之前定位、提供和转换输入文件。构建阶段的第一个钩子是 <font color=#aa1e1e>options</font> ，最后一个钩子总是 <font color=#aa1e1e>buildEnd</font>。如果存在构建错误，<font color=#aa1e1e>closeBundle</font> 将被调用。

<img src="../images/buildHooks.png" width="600" height="721" />

此外，在观察模式下，可以随时触发 [watchChange](https://rollupjs.org/guide/en/#watchchange) 钩子，以通知在当前运行生成其输出后将触发新的钩子函数。此外，当观察程序关闭时，将触发 [closeWatcher](https://rollupjs.org/guide/en/#closewatcher) 钩子。

### options

```ts
Type: (options: InputOptions) => InputOptions | null
Kind: async, sequential
Previous Hook: This is the first hook of the build phase.
Next Hook: buildStart
```

替换或操作传递给 rollup.rollup 的选项对象。返回 null 不会替换任何内容。如果您只需要阅读选项，建议使用 <font color=#aa1e1e>buildStart</font> 钩子，因为在考虑了所有选项钩子的转换后，该钩子可以访问选项。

这是唯一无法 <font color=#aa1e1e>Plugin-Context</font> 函数的钩子，因为它是在 Rollup 配置完成之前运行的。

### buildStart

```ts
Type: (options: InputOptions) => void
Kind: async, parallel
Previous Hook: options
Next Hook: resolveId to resolve each entry point in parallel.
```

被 rollup.rollup 方法调用。当您需要访问传递给 rollup.rollup 的选项时，这是比较推荐使用的钩子，因为它包含了未设置的默认值。

### resolveId

```ts
Type: (source: string, importer: string | undefined, options: {isEntry: boolean, assertions: {[key: string]: string}, custom?: {[plugin: string]: any}}) => string | false | null | {id: string, external?: boolean | "relative" | "absolute", assertions?: {[key: string]: string} | null, meta?: {[plugin: string]: any} | null, moduleSideEffects?: boolean | "no-treeshake" | null, syntheticNamedExports?: boolean | string | null}
Kind: async, first
Previous Hook: buildStart if we are resolving an entry point, moduleParsed if we are resolving an import, or as fallback for resolveDynamicImport. Additionally, this hook can be triggered during the build phase from plugin hooks by calling this.emitFile to emit an entry point or at any time by calling this.resolve to manually resolve an id.
Next Hook: load if the resolved id has not yet been loaded, otherwise buildEnd.
```

定义入口的自定义解析函数。自定义解析函数可用于例如查找第三方依赖项。请看如下例子：

```js
import { foo } from '../bar.js';
```
这里导入了 “../bar.js”

resolveId 钩子接收三个参数分别是 source（源代码），importer（被谁导入），options（选项对象），并且可以返回 string | false | null | object 中的任一值。

options.isEntry 选项将告诉你我们是否正在解析用户定义的入口模块，或者是否为 this.resolve 上下文函数提供了 isEntry 参数。

以下示例演示了自定义解析函数。插件演示了如何自定义“import”的解析。

```js
// We prefix the polyfill id with \0 to tell other plugins not to try to load or
// transform it
const POLYFILL_ID = '\0polyfill';
const PROXY_SUFFIX = '?inject-polyfill-proxy';

function injectPolyfillPlugin() {
  return {
    name: 'inject-polyfill',
    async resolveId(source, importer, options) {
      if (source === POLYFILL_ID) {
        // It is important that side effects are always respected for polyfills,
        // otherwise using "treeshake.moduleSideEffects: false" may prevent the
        // polyfill from being included.
        return { id: POLYFILL_ID, moduleSideEffects: true };
      }
      if (options.isEntry) {
        // Determine what the actual entry would have been. We need "skipSelf"
        // to avoid an infinite loop.
        const resolution = await this.resolve(source, importer, { skipSelf: true, ...options });
        // If it cannot be resolved or is external, just return it so that
        // Rollup can display an error
        if (!resolution || resolution.external) return resolution;
        // In the load hook of the proxy, we need to know if the entry has a
        // default export. There, however, we no longer have the full
        // "resolution" object that may contain meta-data from other plugins
        // that is only added on first load. Therefore we trigger loading here.
        const moduleInfo = await this.load(resolution);
        // We need to make sure side effects in the original entry point
        // are respected even for treeshake.moduleSideEffects: false.
        // "moduleSideEffects" is a writable property on ModuleInfo.
        moduleInfo.moduleSideEffects = true;
        // It is important that the new entry does not start with \0 and
        // has the same directory as the original one to not mess up
        // relative external import generation. Also keeping the name and
        // just adding a "?query" to the end ensures that preserveModules
        // will generate the original entry name for this entry.
        return `${resolution.id}${PROXY_SUFFIX}`;
      }
      return null;
    },
    load(id) {
      if (id === POLYFILL_ID) {
        // Replace with actual polyfill
        return "console.log('polyfill');";
      }
      if (id.endsWith(PROXY_SUFFIX)) {
        const entryId = id.slice(0, -PROXY_SUFFIX.length);
        // We know ModuleInfo.hasDefaultExport is reliable because we awaited
        // this.load in resolveId
        const { hasDefaultExport } = this.getModuleInfo(entryId);
        let code =
          `import ${JSON.stringify(POLYFILL_ID)};` + `export * from ${JSON.stringify(entryId)};`;
        // Namespace reexports do not reexport default, so we need special
        // handling here
        if (hasDefaultExport) {
          code += `export { default } from ${JSON.stringify(entryId)};`;
        }
        return code;
      }
      return null;
    }
  };
}
```

- resolveId 钩子函数如果返回 null 会推迟执行其他的 resolveId 钩子，并最终推迟默认解析行为。如果返回 false，表示 source 应被视为外部模块，而不是包含在捆绑包中。最终的行为和设置 external option 是一样的。

- resolveId 钩子函数如果返回一个 object，则可以将导入解析为不同的 id，同时将其从捆绑包中排除。这允许您将依赖项替换为外部依赖项，而无需用户通过手动将它们标记为"external"：

```js
function externalizeDependencyPlugin() {
  return {
    name: 'externalize-dependency',
    resolveId(source) {
      if (source === 'my-dependency') {
        return { id: 'my-dependency-develop', external: true };
      }
      return null;
    }
  };
}
```

如果 external 设置为 true，则绝对路径id将根据用户对 [makeAbsoluteExternalsRelative](https://rollupjs.org/guide/en/#makeabsoluteexternalsrelative) 选项的选择转换为相对路径id。可以通过设置 external："relative" 以始终将绝对路径id 转换为相对 路径id 或者设置 external: "absolute" 以将其保留为绝对路径id来覆盖此选择。resolveId 钩子函数返回对象时，模块id的相对路径，即以 ./ 或 ../ 不会在内部转换为绝对路径id并在输出中转换回相对路径id，而是原封不动地包含在输出中。如果您希望对相对路径id进行重新规范化和重复数据删除，请将绝对路径作为id返回，然后设置 external: "relative"。

如果在解析模块 ID 的第一个钩子中为 moduleSideEffects 返回 false，并且没有其他模块从该模块导入任何内容，则即使该模块会产生副作用，也不会包含此模块。如果返回 moduleSideEffects: true，则 Rollup 将使用其默认算法在模块中包含具有副作用（如修改全局变量或导出变量）的所有语句。如果返回 moduleSideEffects: “no-treeshake”，则此模块的 “treeshaking” 功能将被关闭，即使它是空的，它也将包含在生成的一个块中。如果返回 moduleSideEffects: null 或省略该标志，则 moduleSideEffects 将由 treeshake.moduleSideEffects 选项确定或默认为 true。<font color=#aa1e1e>load</font>钩子和<font color=#aa1e1e>transform</font>钩子可以覆盖这个行为。

如果返回的对象中包含了断言为 external: true，这将决定在生成“es”格式的模块时如何呈现此模块的导入。例如 {id： “foo”， external： true， assertions： {type： “json”\}} 将导致此模块的 import "foo" 断言 {type： “json”}。如果不传递值，将使用断言输入参数的值。传递空的对象以删除任何断言。虽然断言不会影响最终的 bundle ，但它们仍需要在模块的所有导入中保持一致，否则会发出警告。<font color=#aa1e1e>load</font>钩子和<font color=#aa1e1e>transform</font>钩子可以覆盖这个行为。

有关合成命名导出选项，请参阅[syntheticNamedExports](https://rollupjs.org/guide/en/#synthetic-named-exports)。如果返回 null 或省略该标志，则 syntheticNamedExports 将默认为 false。<font color=#aa1e1e>load</font>钩子和<font color=#aa1e1e>transform</font>钩子可以覆盖这个行为。

有关如何使用 meta 选项，请参阅[custom module meta-data](https://rollupjs.org/guide/en/#custom-module-meta-data)。如果返回 null 或省略该选项，则 meta 将默认为空对象。<font color=#aa1e1e>load</font>钩子和<font color=#aa1e1e>transform</font>钩子可以覆盖这个行为。

>请注意，虽然每次导入模块都会调用 resolveId 钩子，因此可以多次解析为相同的 id，但在加载模块之前，只能设置一次 external、assertions、meta、moduleSideEffects 或 syntheticNamedExports 的值。原因是在调用resolveId 钩子之后，Rollup 将继续使用该模块的<font color=#aa1e1e>load</font>钩子和<font color=#aa1e1e>transform</font>钩子，这些钩子可能会覆盖这些值。

当通过 <font color=#aa1e1e>this.resolve</font> 从插件触发此钩子时，可以将自定义选项对象传递给此钩子。虽然此对象将原封不动地传递，但插件应遵循添加自定义属性的约定，该属性与对象中的键对应于选项所针对的插件的名称。有关详细信息，请参阅[custom resolver options](https://rollupjs.org/guide/en/#custom-resolver-options)。

在观察模式下或显式使用 cache 时，缓存模块的解析导入也会从缓存中获取，并且不会再次通过 resolveId 挂钩确定。为了防止这种情况，你可以从该模块的 <font color=#aa1e1e>shouldTransformCachedModule</font> 钩子返回 true。这将从缓存中删除模块并导入 resolutions，并再次<font color=#aa1e1e>transform</font>钩子和 <font color=#aa1e1e>resolveId</font>钩子。

### load

```ts
Type: (id: string) => string | null | {code: string, map?: string | SourceMap, ast? : ESTree.Program, assertions?: {[key: string]: string} | null, meta?: {[plugin: string]: any} | null, moduleSideEffects?: boolean | "no-treeshake" | null, syntheticNamedExports?: boolean | string | null}
Kind: async, first
Previous Hook: resolveId or resolveDynamicImport where the loaded id was resolved. Additionally, this hook can be triggered at any time from plugin hooks by calling this.load to preload the module corresponding to an id.
Next Hook: transform to transform the loaded file if no cache was used, or there was no cached copy with the same code, otherwise shouldTransformCachedModule.
```

自定义加载函数。返回 null 会推迟其他的 load函数（并最终从文件系统加载的默认行为）。为了防止额外的解析开销，例如，由于某种原因，这个钩子已经使用 this.parse 来生成 AST，这个钩子可以选择返回一个 { code， ast， map } 对象。ast 必须是具有每个节点的开始和结束属性的标准 ESTree AST。可以通过将 map 设置为 null 来保留现有 sourcemap。否则，您可能需要生成 sourcemap。请参阅有关[source code transformations](https://rollupjs.org/guide/en/)。

如果为 moduleSideEffects 返回 false，并且没有其他模块从此模块导入任何内容，则即使该模块会产生副作用，此模块也不会包含在 bundle 中。如果返回 true，则 Rollup 将使用其默认算法在模块中包含具有副作用（如修改全局变量或导出变量）的所有语句。如果返回“no-treeshake”，则此模块的 treeshaking 功能将被关闭，即使它是空的，它也将包含在生成的一个块中。如果返回 null 或省略该标志，则 moduleSideEffects 将由解析此模块的第一个 resolveId 钩子、treeshake.moduleSideEffects 选项决定，或者最终默认为 true。<font color=#aa1e1e>transform</font>钩子可以覆盖这一点。

assertions 选项包含导入此模块时使用的导入断言。目前，它们不会影响 bundled modules 的渲染，而是用于文档目的。如果返回 null 或省略该标志，则断言将由解析此模块的第一个 resolveId 钩子或此模块的第一次导入中存在的断言确定。<font color=#aa1e1e>transform</font>钩子可以覆盖这一点。

有关合成命名导出选项，请参阅[syntheticNamedExports](https://rollupjs.org/guide/en/#synthetic-named-exports)。如果返回 null 或省略该标志，则 syntheticNamedExports 将由解析此模块或最终默认为 false 的第一个 resolveId 钩子确定。<font color=#aa1e1e>transform</font>钩子可以覆盖这个行为。

有关如何使用 meta 选项，请参阅[custom module meta-data](https://rollupjs.org/guide/en/#custom-module-meta-data)。如果此钩子返回了 meta 对象，它将与 resolveId 钩子返回的任何 meta 对象进行浅合并。如果没有钩子返回 meta 对象，它将默认为空对象。<font color=#aa1e1e>transform</font>钩子可以覆盖这个行为。

您可以使用[this.getModuleInfo](https://rollupjs.org/guide/en/#thisgetmoduleinfo)来查看 assertions，meta，moduleSideEffects 和 syntheticNamedExports 的先前值。

### shouldTransformCachedModule

```ts
Type: ({id: string, code: string, ast: ESTree.Program, resolvedSources: {[source: string]: ResolvedId}, assertions: {[key: string]: string}, meta: {[plugin: string]: any}, moduleSideEffects: boolean | "no-treeshake", syntheticNamedExports: boolean | string}) => boolean
Kind: async, first
Previous Hook: load where the cached file was loaded to compare its code with the cached version.
Next Hook: moduleParsed if no plugin returns true, otherwise transform.
```

如果使用 Rollup cache（例如，在观察模式下或通过 JavaScript API），如果在<font color=#aa1e1e>load</font>钩子之后，加载的代码与缓存副本的代码相同，则 Rollup 将跳过模块的<font color=#aa1e1e>transform</font>钩子。为了防止这种情况，请丢弃缓存的副本并转换模块，插件可以实现此钩子并返回 true。

这个钩子还可以用来找出哪些模块被缓存并访问它们缓存的元信息。

如果插件未返回 true，则 Rollup 将为其他插件触发此钩子，否则将跳过所有剩余的插件。

### transform

```js
Type: (code: string, id: string) => string | null | {code?: string, map?: string | SourceMap, ast? : ESTree.Program, assertions?: {[key: string]: string} | null, meta?: {[plugin: string]: any} | null, moduleSideEffects?: boolean | "no-treeshake" | null, syntheticNamedExports?: boolean | string | null}
Kind: async, sequential
Previous Hook: load where the currently handled file was loaded. If caching is used and there was a cached copy of that module, shouldTransformCachedModule if a plugin returned true for that hook.
Next Hook: moduleParsed once the file has been processed and parsed.
```

可用于转换单个模块。为了防止额外的解析开销，例如，由于某种原因，这个钩子已经使用 this.parse 来生成 AST，这个钩子可以选择返回一个 { code， ast， map } 对象。ast 必须是具有每个节点的开始和结束属性的标准 ESTree AST。可以通过将 map 设置为 null 来保留现有的 sourcemap 。否则，您可能需要生成 sourcemap 。请参阅有关[source code transformations](https://rollupjs.org/guide/en/)。

请注意，在观察模式下或使用 cache 时，此钩子函数的结果会在 rebuilding 时缓存，并且只有在模块的代码已更改或上次为此模块触发钩子函数时通过 this.addWatchFile 添加的文件已更改时，才会再次触发模块 ID 的钩子。

在所有其他情况下，将触发 <font color=#aa1e1e>shouldTransformCachedModule</font> 钩子，从而提供对缓存模块的访问。从 shouldTransformCachedModule 返回 true 将从缓存中删除模块，而不是再次调用 transform 。

还可以使用返回值的对象形式来配置模块的其他属性。请注意，可以只返回属性，而不返回代码转换。

如果返回了 moduleSideEffects: false，并且没有其他模块从此模块导入任何内容，则即使该模块会产生副作用，也不会包含此模块。

如果返回 moduleSideEffects: true，则 Rollup 将使用其默认算法在模块中包含具有副作用（如修改全局变量或导出变量）的所有语句。

如果返回 moduleSideEffects: “no-treeshake”，则此模块的 treeshaking 功能将被关闭，即使它是空的，它也将包含在生成的一个块中。

如果返回 null 或省略该标志，则 moduleSideEffects 将由加载此模块的 load钩子、解析此模块的第一个 resolveId钩子、treeshake.moduleSideEffects 选项或最终默认为 true 来确定。

assertions 包含导入此模块时使用的导入断言。目前，它们不会影响 bundled modules 的渲染，而是用于文档目的。如果返回 null 或省略标志，则 assertions 将由加载此模块的 load钩子、解析此模块的第一个 resolveId 钩子或此模块的第一次导入中存在的断言确定。

有关合成命名导出选项，请参阅[syntheticNamedExports](https://rollupjs.org/guide/en/#synthetic-named-exports)。如果返回 null 或省略该标志，则 syntheticNamedExports 将由加载此模块的 load钩子、解析此模块的第一个 resolveId钩子、treeshake.moduleSideEffects 选项或最终默认为 false 确定。

有关如何使用 meta 选项，请参阅[custom module meta-data](https://rollupjs.org/guide/en/#custom-module-meta-data)。如果返回 null 或省略该选项，则 meta 将由加载此模块的 load钩子、解析此模块的第一个 resolveId钩子或最终默认为空对象来确定。

您可以使用<font color=#aa1e1e>this.getModuleInfo</font>来查找此钩子中 assertions，meta，moduleSideEffects 和 syntheticNamedExports 的先前值。

### moduleParsed

```ts
Type: (moduleInfo: ModuleInfo) => void
Kind: async, parallel
Previous Hook: transform where the currently handled file was transformed.
Next Hook: resolveId and resolveDynamicImport to resolve all discovered static and dynamic imports in parallel if present, otherwise buildEnd.
```

每次 Rollup 解析完模块时，都会调用 <font color=#aa1e1e>moduleParsed钩子</font>。请参阅[this.getModuleInfo](https://rollupjs.org/guide/en/#thisgetmoduleinfo)了解传递给此钩子的信息。

与 <font color=#aa1e1e>transform钩子</font>相比，此钩子永远不会缓存，可用于获取有关缓存和其他模块的信息，包括 meta、code 和 ast 的最终值。

此钩子将等到所有的 imports 被 resolved，以便 moduleInfo.importedIds、moduleInfo.dynamicallyImportedIds、moduleInfo.importedIdResolution 和 moduleInfo.dynamicallyImportedIdResolution 中的信息完整且准确。但请注意，有关导入模块的信息可能不完整，因为稍后可能会发现其他导入程序。如果需要此信息，请使用 <font color=#aa1e1e>buildEnd钩子</font>。

### resolveDynamicImport

```ts
Type: (specifier: string | ESTree.Node, importer: string, {assertions: {[key: string]: string}}) => string | false | null | {id: string, external?: boolean | "relative" | "absolute", assertions?: {[key: string]: string} | null, meta?: {[plugin: string]: any} | null, moduleSideEffects?: boolean | "no-treeshake" | null, syntheticNamedExports?: boolean | string | null}
Kind: async, first
Previous Hook: moduleParsed for the importing file.
Next Hook: load if the hook resolved with an id that has not yet been loaded, resolveId if the dynamic import contains a string and was not resolved by the hook, otherwise buildEnd.
```

定义动态导入的自定义解析函数。如果返回 false，表明导入应保持原样，而不是传递给其他解析器，从而使其成为外部解析器。与 resolveId 钩子类似，您也可以返回一个对象以将导入解析为不同的 id，同时将其标记为 external。

assertions 告诉您导入中存在哪些导入断言。例如 import(“foo”， {assert： {type： “json”\}}) 将传递 assertions： {type： “json”}。

如果动态导入将字符串作为参数传递，则从此钩子返回的字符串将被解释为现有模块的 id，如果返回 assertions: null 将延迟其他 resolvers 并最终推迟到 resolveId 钩子。

如果动态导入未将字符串作为参数传递，则此钩子可以访问原始 AST 节点进行分析，并且行为在以下方面略有不同：

- 如果所有插件都返回 null，则导入将被视为 external，并且不会发出警告。
- 如果返回字符串，则此字符串不会解释为模块 ID，而是用作 import 参数的替换。插件有责任确保生成的代码有效。
- 要继续解释当前模块，您仍然可以返回对象 {id， external}。

注意，这个钩子的返回值之后不会传递给 resolveId钩子;如果您需要访问静态解析算法，则可以在插件上下文中调用 <font color=#aa1e1e>this.resolve（source，importer）</font>。


### closeWatcher

```ts
Type: () => void
Kind: async, parallel
Previous/Next Hook: This hook can be triggered at any time both during the build and the output generation phases. If that is the case, the current build will still proceed but no new watchChange events will be triggered ever.
```

在观察程序进程关闭时通知插件，以便也可以关闭所有打开的资源。如果返回 Promise，Rollup 将等待 Promise resolved 然后再关闭进程。此钩子不能用于 output plugins。

### watchChange

```ts
Type: watchChange: (id: string, change: {event: 'create' | 'update' | 'delete'}) => void
Kind: async, parallel
Previous/Next Hook: This hook can be triggered at any time both during the build and the output generation phases. If that is the case, the current build will still proceed but a new build will be scheduled to start once the current build has completed, starting again with options.
```

每当 Rollup 检测到在 --watch 模式下对受观察文件的更改时，都会通知此钩子。如果返回 Promise，Rollup 将等待 Promise 变成 resolved，然后再规划另一个 build。output plugins 不能使用此钩子。第二个参数里面包含更改事件的详细信息。

### buildEnd

```ts
Type: (error?: Error) => void
Kind: async, parallel
Previous Hook: moduleParsed, resolveId or resolveDynamicImport.
Next Hook: outputOptions in the output generation phase as this is the last hook of the build phase.
```

当 Rollup 完成 bundling 时，但在调用 generate 或 write 之前调用; 您也可以返回一个 Promise 。如果在 build 中发生错误则会传递到此钩子。

