# renderChunks

await renderChunks(chunks, outputBundle, this.pluginDriver, this.outputOptions, this.inputOptions.onwarn); 函数内部主要逻辑可以分为以下几步：

1. 设置入口 chunk 的 preliminaryFileName
2. 执行chunk.render()
3. 生成 chunkGraph
4. addChunksToBundle

renderChunks 主要作用是生成最终的 outputBundle。例如：

```js
{index.js: {…}, acorn-bf6b1c54.js: {…}}
```
最终 bundle.generate 函数内部将 outputBundleBase 返回。

它的代码定义在： src/utils/renderChunks.ts

```ts
export async function renderChunks(
	chunks: Chunk[],
	bundle: OutputBundleWithPlaceholders,
	pluginDriver: PluginDriver,
	outputOptions: NormalizedOutputOptions,
	onwarn: WarningHandler
) {
	//设置入口 chunk 的 preliminaryFileName
	reserveEntryChunksInBundle(chunks);
	//chunk.render()
	const renderedChunks = await Promise.all(chunks.map(chunk => chunk.render()));
	//生成 chunkGraph
	const chunkGraph = getChunkGraph(chunks);
	const {
		nonHashedChunksWithPlaceholders,
		renderedChunksByPlaceholder,
		hashDependenciesByPlaceholder
	} = await transformChunksAndGenerateContentHashes(
		renderedChunks,
		chunkGraph,
		outputOptions,
		pluginDriver,
		onwarn
	);
	const hashesByPlaceholder = generateFinalHashes(
		renderedChunksByPlaceholder,
		hashDependenciesByPlaceholder,
		bundle
	);
	addChunksToBundle(
		renderedChunksByPlaceholder,
		hashesByPlaceholder,
		bundle,
		nonHashedChunksWithPlaceholders,
		pluginDriver,
		outputOptions
	);
}
```

reserveEntryChunksInBundle(chunks); 的目的是为了设置入口 chunk 的 preliminaryFileName。

```ts
function reserveEntryChunksInBundle(chunks: Chunk[]) {
	for (const chunk of chunks) {
		if (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint) {
			// reserves name in bundle as side effect if it does not contain a hash
			chunk.getPreliminaryFileName();
		}
	}
}

getPreliminaryFileName(): PreliminaryFileName {
  if (this.preliminaryFileName) {
    return this.preliminaryFileName;
  }
  let fileName: string;
  let hashPlaceholder: string | null = null;
  const { chunkFileNames, entryFileNames, file, format, preserveModules } = this.outputOptions;
  if (file) {
    fileName = basename(file);
  } else if (this.fileName !== null) {
    fileName = this.fileName;
  } else {
    const [pattern, patternName] =
      preserveModules || this.facadeModule?.isUserDefinedEntryPoint
        ? [entryFileNames, 'output.entryFileNames']
        : [chunkFileNames, 'output.chunkFileNames'];
    fileName = renderNamePattern(
      typeof pattern === 'function' ? pattern(this.getPreRenderedChunkInfo()) : pattern,
      patternName,
      {
        format: () => format,
        hash: size =>
          hashPlaceholder || (hashPlaceholder = this.getPlaceholder(patternName, size)),
        name: () => this.getChunkName()
      }
    );
    if (!hashPlaceholder) {
      fileName = makeUnique(fileName, this.bundle);
    }
  }
  if (!hashPlaceholder) {
    this.bundle[fileName] = FILE_PLACEHOLDER;
  }
  // Caching is essential to not conflict with the file name reservation above
  return (this.preliminaryFileName = { fileName, hashPlaceholder });
}
```

const renderedChunks = await Promise.all(chunks.map(chunk => chunk.render())); 

chunk.render 方法会返回一个 ChunkRenderResult 对象。
```ts

export interface ChunkRenderResult {
	chunk: Chunk;
	magicString: MagicStringBundle;
	preliminaryFileName: PreliminaryFileName;
	usedModules: Module[];
}

class Chunk{
  //...
  async render(): Promise<ChunkRenderResult> {
		const {
			dependencies,
			exportMode,
			facadeModule,
			inputOptions: { onwarn },
			outputOptions,
			pluginDriver,
			snippets
		} = this;
		const { format, hoistTransitiveImports, preserveModules } = outputOptions;

		// for static and dynamic entry points, add transitive dependencies to this
		// chunk's dependencies to avoid loading latency
		// 设置入口chunk 的 dependencies (设置this.dependencies)
		if (hoistTransitiveImports && !preserveModules && facadeModule !== null) {
			for (const dep of dependencies) {
				if (dep instanceof Chunk) this.inlineChunkDependencies(dep);
			}
		}
		// preliminaryFileName => { fileName: 'index.js', hashPlaceholder: null }
		const preliminaryFileName = this.getPreliminaryFileName();
		const { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait } =
			this.renderModules(preliminaryFileName.fileName);
		//当前 render 的 dependencies,即 imported 信息
		const renderedDependencies = [...this.getRenderedDependencies().values()];
		//当前 render 的 exports,即 exported 信息
		const renderedExports = exportMode === 'none' ? [] : this.getChunkExportDeclarations(format);
		let hasExports = renderedExports.length > 0;
		let hasDefaultExport = false;
		//判断是否有默认导出
		for (const { reexports } of renderedDependencies) {
			if (reexports?.length) {
				hasExports = true;
				if (reexports.some(reexport => reexport.reexported === 'default')) {
					hasDefaultExport = true;
					break;
				}
			}
		}
		if (!hasDefaultExport) {
			for (const { exported } of renderedExports) {
				if (exported === 'default') {
					hasDefaultExport = true;
					break;
				}
			}
		}

		const { intro, outro, banner, footer } = await createAddons(
			outputOptions,
			pluginDriver,
			this.getRenderedChunkInfo()
		);
		/**
		 * finalisers[format] 其实执行的是最终的打包 format 的function。
		 * 它的目的是为了对 renderedSource 做进一步的处理。
		 * 例如当 format === 'es' 的时候且 bundle 引入了外部的依赖，则需要执行 magicString.prepend()方法在 bundle 头部加上 import 语句。
		 * 如果有导出变量则需要执行 magicString.append() 方法将导出语句加在 bundle 的尾部。
		 */
		finalisers[format](
			renderedSource,
			{
				accessedGlobals,
				dependencies: renderedDependencies,
				exports: renderedExports,
				hasDefaultExport,
				hasExports,
				id: preliminaryFileName.fileName,
				indent,
				intro,
				isEntryFacade: preserveModules || (facadeModule !== null && facadeModule.info.isEntry),
				isModuleFacade: facadeModule !== null,
				namedExportsMode: exportMode !== 'default',
				onwarn,
				outro,
				snippets,
				usesTopLevelAwait
			},
			outputOptions
		);
		if (banner) magicString.prepend(banner);
		if (footer) magicString.append(footer);

		return {
			chunk: this,
			magicString,
			preliminaryFileName,
			usedModules
		};
	}
  /**
	 * inlineChunkDependencies 主要是将所有的外部依赖都收集起来
	 * 举例子，最终生成 bundle 的时候,如果 bundle 引入了第三方的js库（acorn），
	 * 则需要在文件的顶部插入 import { a as acorn } from './acorn-bf6b1c54.js';
	 */
  private inlineChunkDependencies(chunk: Chunk): void {
		for (const dep of chunk.dependencies) {
			if (this.dependencies.has(dep)) continue;
			this.dependencies.add(dep);
			if (dep instanceof Chunk) {
				this.inlineChunkDependencies(dep);
			}
		}
	}

  private renderModules(fileName: string) {
		const {
			accessedGlobalsByScope,
			dependencies,
			exportNamesByVariable,
			includedNamespaces,
			inputOptions: { onwarn },
			isEmpty,
			orderedModules,
			outputOptions,
			pluginDriver,
			renderedModules,
			snippets
		} = this;
		const {
			compact,
			dynamicImportFunction,
			format,
			freeze,
			namespaceToStringTag,
			preserveModules
		} = outputOptions;
		const { _, cnst, n } = snippets;
		//更新 ImportExpression 的属性。例如inlineNamespace，resolution，assertions 等等
		this.setDynamicImportResolutions(fileName);
		//设置 importMeta 属性和 accessedGlobalsByScope
		this.setImportMetaResolutions(fileName);
		//防止变量命名冲突
		this.setIdentifierRenderResolutions();

		const magicString = new MagicStringBundle({ separator: `${n}${n}` });
		const indent = getIndentString(orderedModules, outputOptions);
		const usedModules: Module[] = [];
		let hoistedSource = '';
		const accessedGlobals = new Set<string>();
		const renderedModuleSources = new Map<Module, MagicString>();

		const renderOptions: RenderOptions = {
			dynamicImportFunction,
			exportNamesByVariable,
			format,
			freeze,
			indent,
			namespaceToStringTag,
			pluginDriver,
			snippets
		};

		let usesTopLevelAwait = false;
		for (const module of orderedModules) {
			let renderedLength = 0;
			let source: MagicString | undefined;
			if (module.isIncluded() || includedNamespaces.has(module)) {
				const rendered = module.render(renderOptions);
				({ source } = rendered);
				usesTopLevelAwait ||= rendered.usesTopLevelAwait;
				renderedLength = source.length();
				if (renderedLength) {
					if (compact && source.lastLine().includes('//')) source.append('\n');
					renderedModuleSources.set(module, source);
					magicString.addSource(source);
					usedModules.push(module);
				}
				const namespace = module.namespace;
				if (includedNamespaces.has(module) && !preserveModules) {
					const rendered = namespace.renderBlock(renderOptions);
					if (namespace.renderFirst()) hoistedSource += n + rendered;
					else magicString.addSource(new MagicString(rendered));
				}
				const accessedGlobalVariables = accessedGlobalsByScope.get(module.scope);
				if (accessedGlobalVariables) {
					for (const name of accessedGlobalVariables) {
						accessedGlobals.add(name);
					}
				}
			}
			const { renderedExports, removedExports } = module.getRenderedExports();
			renderedModules[module.id] = {
				get code() {
					return source?.toString() ?? null;
				},
				originalLength: module.originalCode.length,
				removedExports,
				renderedExports,
				renderedLength
			};
		}

		if (hoistedSource) magicString.prepend(hoistedSource + n + n);

		// eslint-disable-next-line unicorn/consistent-destructuring
		if (this.needsExportsShim) {
			magicString.prepend(`${n}${cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);
		}
		const renderedSource = compact ? magicString : magicString.trim();

		if (isEmpty && this.getExportNames().length === 0 && dependencies.size === 0) {
			onwarn(errorEmptyChunk(this.getChunkName()));
		}
		return { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait };
	}
}
```
**this.renderModules(preliminaryFileName.fileName) 是 "generate" 阶段的关键方法，this.renderModules 会调用 module.render() 生成 source，然后执行 magicString.addSource(source) 将多个 source 拼接成 bundle。**

执行 this.renderModules 内部会得到如下一个对象。因为篇幅有限，下一节内容我们会对这个函数继续深入分析内部逻辑。

```js

{ 
	accessedGlobals, // 访问过的全局变量
	indent,   // 缩进，默认’\t‘
	magicString,  // MagicStringBundle
	renderedSource, // magicString.trim()
	usedModules,   // 被包含的模块（不含手动模块（manualChunks））
	usesTopLevelAwait  // 是否允许顶层的 “await”, 默认 false
}

```

我们接着回到 Chunk.render 方法内部，执行完this.renderModules(preliminaryFileName.fileName)方法会得到上面的对象。

const renderedDependencies = [...this.getRenderedDependencies().values()]; 这个 renderedDependencies 就是当前 render 的 dependencies,即 imported 信息。

const renderedExports = exportMode === 'none' ? [] : this.getChunkExportDeclarations(format); renderedExports 就是当前 render 的 exports 信息。

接着的 for (const { reexports } of renderedDependencies) 语句内部和 if (!hasDefaultExport) 语句内部的逻辑都是判断了 hasDefaultExport 是 true 还是 false。

```ts
const { intro, outro, banner, footer } = await createAddons(
	outputOptions,
	pluginDriver,
	this.getRenderedChunkInfo()
);
```
上面这段代码就是获取用户的配置信息，例如 banner, footer 等等。

```ts
finalisers[format](
		renderedSource,
		{
			accessedGlobals,
			dependencies: renderedDependencies,
			exports: renderedExports,
			hasDefaultExport,
			hasExports,
			id: preliminaryFileName.fileName,
			indent,
			intro,
			isEntryFacade: preserveModules || (facadeModule !== null && facadeModule.info.isEntry),
			isModuleFacade: facadeModule !== null,
			namedExportsMode: exportMode !== 'default',
			onwarn,
			outro,
			snippets,
			usesTopLevelAwait
		},
		outputOptions
	);
	if (banner) magicString.prepend(banner);
	if (footer) magicString.append(footer);
```
执行 finalisers\[format] 其实执行的是 src/finalisers 路径下定义的\[format].js 方法。它的目的是为了对 renderedSource 做进一步的处理。例如当 format === 'es' 的时候且 bundle 引入了外部的依赖，则需要执行 magicString.prepend() 方法在 bundle 头部加上 import 语句。如果有导出变量则需要执行 magicString.append() 方法将导出语句加在 bundle 的尾部。最终 chunk.render() 方法返回了如下对象：

```ts
return {
	chunk: this, 
	magicString,  //magicStringBundle
	preliminaryFileName,  // bundle fileName
	usedModules
};
```

# chunk.render 总结

chunk.render() 内部主要逻辑：

1. 设置入口chunk 的 dependencies (设置this.dependencies)
2. 执行 this.renderModules 生成 magicStringBundle 
3. 执行 finalisers\[format] 对 magicStringBundle 进行加工