# node.hasEffects

通俗的理解 node.hasEffects 其实就是指节点是否影响最终的 bundle 。**rollup 中的 "Tree shaking" 的主要原理就是先将所有的 node 标记为 included 为 true 或者 false, 最终统一对 included 为 false 的 node 进行字符串的删除或者替换操作来达到删除无用代码的效果。** 因此我们这一章节将会对所有的 nodeType 进行 hasEffects 逻辑分析。

## NodeBase

```js
class NodeBase {
  //...
  hasEffects(context: HasEffectsContext): boolean {
    if (!this.deoptimized) this.applyDeoptimizations();
    for (const key of this.keys) {
      const value = (this as GenericEsTreeNode)[key];
      if (value === null) continue;
      if (Array.isArray(value)) {
        for (const child of value) {
          if (child?.hasEffects(context)) return true;
        }
      } else if (value.hasEffects(context)) return true;
    }
    return false;
  }
  //...
}
```

## 1.ArrayExpression (数组表达式)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ArrayExpression.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ArrayExpression {
  type: 'ArrayExpression';
  elements: Array<null | Expression | SpreadElement>; //(default: [])
}
```

例：

```js
[1, 2, 3];
```

## 2.ArrayPattern (数组解析模式)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ArrayPattern.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ArrayPattern {
  type: 'ArrayPattern';
  elements: Array<null | PatternLike>; //(required);
}
```

例：

```js
const [a, b, c] = [1, 2, 3];
```

## 3.ArrowFunctionExpression (箭头函数表达式)

hasEffects 默认返回 false

```ts
hasEffects(): boolean {
  if (!this.deoptimized) this.applyDeoptimizations();
  return false;
}
```

AST Node shape:

```ts
interface ArrowFunctionExpression {
  type: 'ArrowFunctionExpression';
  params: Array<Identifier | Pattern | RestElement>;
  body: BlockStatement | Expression;
  async: boolean; //(default: false)
  expression: boolean; //(required)
  generator: boolean; //(default: false, excluded from builder function)
  predicate: DeclaredPredicate | InferredPredicate; //(default: null, excluded from builder function)
  returnType: TypeAnnotation | TSTypeAnnotation | Noop; //(default: null, excluded from builder function)
  typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop; //(default: null, excluded from builder function)
}
```

例：

```js
const getArray = () => [1, 2, 3];
```

## 4.AssignmentExpression (赋值表达式)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  const { deoptimized, left, operator, right } = this;
  if (!deoptimized) this.applyDeoptimizations();
  // MemberExpressions do not access the property before assignments if the
  // operator is '='.
  return (
    right.hasEffects(context) || left.hasEffectsAsAssignmentTarget(context, operator !== '=')
  );
}
```

AST Node shape:

```ts
interface AssignmentExpression {
  type: 'AssignmentExpression';
  operator:
    | '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '<<='
    | '>>='
    | '>>>='
    | '|='
    | '^='
    | '&='
    | '**=';
  left: Expression; //(required);
  right: Expression; //(required);
}
```

例：

```js
a += 1;
```

## 5.AssignmentPattern (赋值模式。常用于解构赋值)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 AssignmentPattern.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface AssignmentPattern {
  type: 'AssignmentPattern';
  left:
    | Identifier
    | ObjectPattern
    | ArrayPattern
    | MemberExpression
    | TSAsExpression
    | TSTypeAssertion
    | TSNonNullExpression; //(required)
  right: Expression; //(required)
  decorators: Array<Decorator>; //(default: null, excluded from builder function)
  typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop; //(default: null, excluded from builder function)
}
```

例：

```js
const [a, b, c = 3] = [1, 2, 3];
```

## 6.AwaitExpression (await 表达式)

hasEffects 默认返回 true

```ts
hasEffects(): boolean {
  if (!this.deoptimized) this.applyDeoptimizations();
  return true;
}
```

AST Node shape:

```ts
interface AwaitExpression {
  type: 'AwaitExpression';
  argument: Expression; //(required)
}
```

例：

```js
await foo();
```

## 7.BinaryExpression (二元表达式)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  // support some implicit type coercion runtime errors
  if (
    this.operator === '+' &&
    this.parent instanceof ExpressionStatement &&
    this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === ''
  ) {
    return true;
  }
  return super.hasEffects(context);
}
```

AST Node shape:

```ts
interface BinaryExpression {
  type: 'BinaryExpression';
  operator:
    | '+'
    | '-'
    | '/'
    | '%'
    | '*'
    | '**'
    | '&'
    | '|'
    | '>>'
    | '>>>'
    | '<<'
    | '^'
    | '=='
    | '==='
    | '!='
    | '!=='
    | 'in'
    | 'instanceof'
    | '>'
    | '<'
    | '>='
    | '<='
    | '|>'; // (required)
  left: Expression | PrivateName; // (required)
  right: Expression; // (required)
}
```

例：

```js
let a = 1;
let b = 2;
if (a === b) {
  //
}
```

## 8.BlockStatement (块语句)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  if (this.deoptimizeBody) return true;
  for (const node of this.body) {
    if (context.brokenFlow) break;
    if (node.hasEffects(context)) return true;
  }
  return false;
}
```

AST Node shape:

```ts
interface BlockStatement {
  type: 'BlockStatement';
  body: Array<Statement>; // (required)
}
```

例：

```js
{
  console.log(123);
}
```

## 9.BreakStatement (break 语句)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
		if (this.label) {
			if (!context.ignore.labels.has(this.label.name)) return true;
			context.includedLabels.add(this.label.name);
			context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
		} else {
			if (!context.ignore.breaks) return true;
			context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;
		}
		return false;
	}
```

AST Node shape:

```ts
interface BreakStatement {
  type: 'BreakStatement';
  label: Identifier; // (default: null)
}
```

例：

```js
for (const node of [1, 2, 3]) {
  if (node >= 2) break;
  console.log(node);
}
```

## 10.CallExpression (函数执行表达式)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  try {
    for (const argument of this.arguments) {
      if (argument.hasEffects(context)) return true;
    }
    if (
      (this.context.options.treeshake as NormalizedTreeshakingOptions).annotations &&
      this.annotations
    )
      return false;
    return (
      this.callee.hasEffects(context) ||
      this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context)
    );
  } finally {
    if (!this.deoptimized) this.applyDeoptimizations();
  }
}
```

AST Node shape:

```ts
interface CallExpression {
  type: 'CallExpression';
  callee: Expression | V8IntrinsicIdentifier; // (required)
  arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>; // (required)
  optional: true | false; // (default: null, excluded from builder function)
}
```

例：

```js
const foo = () => {};
foo();
```

## 11.CatchClause (catch 语句)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 CatchClause.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface CatchClause {
  type: 'CatchClause';
  param: Identifier | ArrayPattern | ObjectPattern; // (default: null)
  body: BlockStatement; // (required)
}
```

例：

```js
try {
  foo();
} catch (e) {
  console.error(e);
} finally {
  bar();
}
```

## 12.ClassBody (class Body)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ClassBody.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ClassBody {
  type: 'ClassBody';
  body: Array<
    | ClassMethod
    | ClassPrivateMethod
    | ClassProperty
    | ClassPrivateProperty
    | ClassAccessorProperty
    | TSDeclareMethod
    | TSIndexSignature
    | StaticBlock
  >; //(required)
}
```

例：

```js
class foo {
  constructor() {}
  method() {}
}
```

## 13.ClassDeclaration (class 声明)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ClassDeclaration.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ClassDeclaration {
  type: 'ClassDeclaration';
  id: Identifier; // (required)
  superClass: Expression; // (default: null)
  body: ClassBody; // (required)
}
```

例：

```js
class foo {
  constructor() {}
  method() {}
}
```

## 14.ClassExpression (class 表达式)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ClassExpression.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ClassExpression {
  type: 'ClassExpression';
  id: Identifier; // (required)
  superClass: Expression; // (default: null)
  body: ClassBody; // (required)
}
```

例：

```js
const foo = class {
  constructor() {}
  method() {}
};
```

## 15.ConditionalExpression (条件表达式)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  if (this.test.hasEffects(context)) return true;
  const usedBranch = this.getUsedBranch();
  if (!usedBranch) {
    return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);
  }
  return usedBranch.hasEffects(context);
}
```

AST Node shape:

```ts
interface ConditionalExpression {
  type: 'ConditionalExpression';
  test: Expression; // (required)
  consequent: Expression; // (required)
  alternate: Expression; // (required)
}
```

例：

```js
const a = true ? 'consequent' : 'alternate';
```

## 16.ContinueStatement (continue 语句)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  if (this.label) {
    if (!context.ignore.labels.has(this.label.name)) return true;
    context.includedLabels.add(this.label.name);
    context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
  } else {
    if (!context.ignore.continues) return true;
    context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;
  }
  return false;
}
```

AST Node shape:

```ts
interface ContinueStatement {
  type: 'ContinueStatement';
  label: Identifier; // (default: null)
}
```

例：

```js
for (const node of [1, 2, 3]) {
  if (node === 2) continue;
  console.log(node);
}
```

## 17.DoWhileStatement (do-while 语句)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  if (this.test.hasEffects(context)) return true;
  const { brokenFlow, ignore } = context;
  const { breaks, continues } = ignore;
  ignore.breaks = true;
  ignore.continues = true;
  if (this.body.hasEffects(context)) return true;
  ignore.breaks = breaks;
  ignore.continues = continues;
  context.brokenFlow = brokenFlow;
  return false;
}
```

AST Node shape:

```ts
interface DoWhileStatement {
  type: 'DoWhileStatement';
  test: Expression; // (required)
  body: Statement; // (required)
}
```

例：

```js
do {} while (a >= 1);
```

## 18.EmptyStatement (空语句)

hasEffects 默认返回 false

```ts
hasEffects(): boolean {
  return false;
}
```

AST Node shape:

```ts
interface EmptyStatement {
  type: 'EmptyStatement';
}
```

例：

```js
for (const node of [1, 2, 3]);
```

## 19.ExportAllDeclaration (导出所有声明)

hasEffects 默认返回 false

```ts
hasEffects(): boolean {
  return false;
}
```

AST Node shape:

```ts
interface ExportAllDeclaration {
  type: 'ExportAllDeclaration';
  source: StringLiteral; // (required)
}
```

例：

```js
export * from './user';
```

## 20.ExportDefaultDeclaration (导出默认声明)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ExportDefaultDeclaration.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ExportDefaultDeclaration {
  type: 'ExportDefaultDeclaration';
  declaration: FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression; // (required)
}
```

例：

```js
export default 'foo';
```

## 21.ExportNamedDeclaration (导出带名称的声明)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  return !!this.declaration?.hasEffects(context);
}
```

AST Node shape:

```ts
interface ExportNamedDeclaration {
  type: 'ExportNamedDeclaration';
  declaration: Declaration; // (default: null)
  specifiers: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>; // (default: [])
  source: StringLiteral; // (default: null)
}
```

例：

```js
const foo = 'foo';
export { foo };
// 或者 export const foo = 'foo';
```

## 22.ExpressionStatement (表达式语句)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ExpressionStatement.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ExpressionStatement {
  type: 'ExpressionStatement';
  expression: Expression; // (required)
}
```

例：

```js
(function foo() {})();
```

## 23.ForInStatement (for...in 语句)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  const { body, deoptimized, left, right } = this;
  if (!deoptimized) this.applyDeoptimizations();
  if (left.hasEffectsAsAssignmentTarget(context, false) || right.hasEffects(context)) return true;
  const { brokenFlow, ignore } = context;
  const { breaks, continues } = ignore;
  ignore.breaks = true;
  ignore.continues = true;
  if (body.hasEffects(context)) return true;
  ignore.breaks = breaks;
  ignore.continues = continues;
  context.brokenFlow = brokenFlow;
  return false;
}
```

AST Node shape:

```ts
interface ForInStatement {
  type: 'ForInStatement';
  left: VariableDeclaration | LVal; // (required)
  right: Expression; // (required)
  body: Statement; // (required)
}
```

例：

```js
for (let item in [1, 2, 3]) {
}
```

## 24.ForOfStatement (for...of 语句)

hasEffects 默认返回 true

```ts
hasEffects(): boolean {
  if (!this.deoptimized) this.applyDeoptimizations();
  // Placeholder until proper Symbol.Iterator support
  return true;
}
```

AST Node shape:

```ts
interface ForOfStatement {
  type: 'ForOfStatement';
  left: VariableDeclaration | LVal; // (required)
  right: Expression; // (required)
  body: Statement; // (required)
}
```

例：

```js
for (let item of [1, 2, 3]) {
}
```

## 25.ForStatement (for 语句)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  if (
    this.init?.hasEffects(context) ||
    this.test?.hasEffects(context) ||
    this.update?.hasEffects(context)
  )
    return true;
  const { brokenFlow, ignore } = context;
  const { breaks, continues } = ignore;
  ignore.breaks = true;
  ignore.continues = true;
  if (this.body.hasEffects(context)) return true;
  ignore.breaks = breaks;
  ignore.continues = continues;
  context.brokenFlow = brokenFlow;
  return false;
}
```

AST Node shape:

```ts
interface ForStatement {
  type: 'ForStatement';
  init: VariableDeclaration | Expression; // (default: null) 例如：let a = 1;
  test: Expression; // (default: null) 例如：a++;
  update: Expression; // (default: null) 例如：a < 3
  body: Statement; // (required)
}
```

例：

```js
for (let a = 1; a++; a < 3) {}
```

## 26.FunctionDeclaration (for 语句)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 FunctionDeclaration.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface FunctionDeclaration {
  type: 'FunctionDeclaration';
  id: Identifier; // (default: null)
  expression: boolean; // (default: false)
  generator: boolean; // (default: false)
  async: boolean; // (default: false)
  params: Array<Identifier | Pattern | RestElement>;
  body: BlockStatement; // (required)
}
```

例：

```js
function foo() {}
//或者 function *foo(){}
```

## 26.FunctionExpression (函数表达式)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 FunctionExpression.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface FunctionExpression {
  type: 'FunctionExpression';
  id: Identifier; // (default: null)
  expression: boolean; // (default: false)
  generator: boolean; // (default: false)
  async: boolean; // (default: false)
  params: Array<Identifier | Pattern | RestElement>;
  body: BlockStatement; // (required)
}
```

例：

```js
const foo = function () {};
```

## 27.Identifier (标识符。就是我们写 JS 时自定义的名称，如变量名，函数名，属性名，统称为标识符。)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
		if (!this.deoptimized) this.applyDeoptimizations();
		if (this.isPossibleTDZ() && this.variable!.kind !== 'var') {
			return true;
		}
		return (
			(this.context.options.treeshake as NormalizedTreeshakingOptions).unknownGlobalSideEffects &&
			this.variable instanceof GlobalVariable &&
			this.variable.hasEffectsOnInteractionAtPath(
				EMPTY_PATH,
				NODE_INTERACTION_UNKNOWN_ACCESS,
				context
			)
		);
	}
```

AST Node shape:

```ts
interface Identifier {
  type: 'Identifier';
  name: string;
}
```

例：

```js
const foo = function () {};
//这个foo就是 Identifier
```

## 28.IfStatement (if 语句)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
		if (this.test.hasEffects(context)) {
			return true;
		}
		const testValue = this.getTestValue();
		if (typeof testValue === 'symbol') {
			const { brokenFlow } = context;
			if (this.consequent.hasEffects(context)) return true;
			// eslint-disable-next-line unicorn/consistent-destructuring
			const consequentBrokenFlow = context.brokenFlow;
			context.brokenFlow = brokenFlow;
			if (this.alternate === null) return false;
			if (this.alternate.hasEffects(context)) return true;
			context.brokenFlow =
				// eslint-disable-next-line unicorn/consistent-destructuring
				context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
			return false;
		}
		return testValue ? this.consequent.hasEffects(context) : !!this.alternate?.hasEffects(context);
	}
```

AST Node shape:

```ts
interface IfStatement {
  type: 'IfStatement';
  test: Expression; // (required)
  consequent: Statement; // (required)
  alternate: Statement; // (default: null)
}
```

例：

```js
if (a > 1) {
}
```

## 29.ImportDeclaration (import 声明)

hasEffects 默认返回 false

```ts
hasEffects(): boolean {
  return false;
}
```

AST Node shape:

```ts
interface ImportDeclaration {
  type: 'ImportDeclaration';
  specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>; // (required)
  source: StringLiteral; // (required)
}
```

例：

```js
import { foo } from './user';
```

## 30.ImportDeclaration (import 声明)

hasEffects 默认返回 false

```ts
hasEffects(): boolean {
  return false;
}
```

AST Node shape:

```ts
interface ImportDeclaration {
  type: 'ImportDeclaration';
  specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>; // (required)
  source: StringLiteral; // (required)
}
```

例：

```js
import { foo } from './user'; //这个“foo” 就是 ImportSpecifier
```

## 31.ImportDefaultSpecifier (默认导入的标识符)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ImportDefaultSpecifier.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ImportDefaultSpecifier {
  type: 'ImportDefaultSpecifier';
  local: Identifier; // (required)
}
```

例：

```js
import foo from './user'; //这个“foo” 就是 ImportDefaultSpecifier
```

## 32.ImportExpression (import 表达式)

hasEffects 默认返回 true

```ts
hasEffects(): boolean {
  return true;
}
```

AST Node shape:

```ts
interface ImportExpression {
  type: 'ImportExpression';
  source: StringLiteral; // (required)
}
```

例：

```js
import('./user'); //source.value = './user'
```

## 33.ImportNamespaceSpecifier (带命名空间的导入标识符)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ImportNamespaceSpecifier.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ImportNamespaceSpecifier {
  type: 'ImportNamespaceSpecifier';
  local: Identifier; // (required)
}
```

例：

```js
import * as foo from './foo'; //ImportNamespaceSpecifier => '* as foo'
```

## 34.ImportSpecifier (导入标识符)

没有自己的 hasEffects 方法。它继承自 NodeBase 因此 ImportSpecifier.hasEffects 实际上执行的是 NodeBase.hasEffects。

AST Node shape:

```ts
interface ImportSpecifier {
  type: 'ImportSpecifier';
  local: Identifier; // (required)
  imported: Identifier | StringLiteral; // (required)
}
```

例：

```js
import { foo } from './foo';
//ImportSpecifier => 'foo'
// local => 'foo'
```

## 35.LabeledStatement (label 语句,又称为标记语句。作用是在语句前面加个可以引用的标识符。相当于将一条语句存储在一个变量里面,类似函数的函数名。)

hasEffects

```ts
hasEffects(context: HasEffectsContext): boolean {
  const brokenFlow = context.brokenFlow;
  context.ignore.labels.add(this.label.name);
  if (this.body.hasEffects(context)) return true;
  context.ignore.labels.delete(this.label.name);
  if (context.includedLabels.has(this.label.name)) {
    context.includedLabels.delete(this.label.name);
    context.brokenFlow = brokenFlow;
  }
  return false;
}
```

AST Node shape:

```ts
interface LabeledStatement {
  type: 'LabeledStatement';
  label: Identifier; // (required)
  body: Statement; // (required)
}
```

例：

```js
/**
 * label语句一般与 break 或者 continue 代码块一起使用
 * */

//下面这个例子在双重for循环中,实现了在内层循环结束掉外层循环的功能。
out: for (let i = 0; i < 5; i++) {
  console.log('i', i);
  for (let j = 0; j < 5; j++) {
    console.log('j', j);
    if (i == 2) {
      //todo
      break out;
    }
  }
}

//下面的例子中当i===2的时候会跳过最外层的for循环一次，因此两个for循环都只能循环4次
out: for (let i = 0; i < 5; i++) {
  for (let j = 0; j < 5; j++) {
    console.log('j', j);
    if (i == 2) {
      //todo
      continue out;
    }
  }
  console.log('i', i);
}

/**
 * 与代码块一起使用
 * */
out: {
  console.log(1);
  break out;
  console.log(2);
}
console.log(3);
//依次打印 1、3
```
