# includeStatements

tree-shaking 本来做的是删除代码的意思。我们需要注意的是 rollup 在删除无用代码之前是先将代码标记为“included” ，最后调用 includeStatements() 将需要保留的代码打包到 chunks 中。接下来我们继续分析 this.includeStatements() 的逻辑。

```js
class Graph {
  //...
  async build(): Promise<void> {
    //...
    //遍历所有的ast.node并且修改node.included的值
    this.includeStatements();
    //...
  }
  private includeStatements(): void {
		for (const module of [...this.entryModules, ...this.implicitEntryModules]) {
      //标记模块 isExecuted = true;
			markModuleAndImpureDependenciesAsExecuted(module);
		}
		if (this.options.treeshake) {
			let treeshakingPass = 1;
			do {
				timeStart(`treeshaking pass ${treeshakingPass}`, 3);
				this.needsTreeshakingPass = false;
				for (const module of this.modules) {
					if (module.isExecuted) {
						if (module.info.moduleSideEffects === 'no-treeshake') {
							module.includeAllInBundle();
						} else {
							module.include();
						}
					}
				}
				if (treeshakingPass === 1) {
					// 仅需在第一次的时候将模块内的导出语句包含进来
					for (const module of [...this.entryModules, ...this.implicitEntryModules]) {
						//module.preserveSignature => 'exports-only'
						if (module.preserveSignature !== false) {
							module.includeAllExports(false);
							this.needsTreeshakingPass = true;
						}
					}
				}
				timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);
			} while (this.needsTreeshakingPass); //this.needsTreeshakingPass为true的时候才会继续执行treeShaking逻辑
		} else {
			for (const module of this.modules) module.includeAllInBundle();
		}
		//...
	}
  //...
}
```

includeStatements 内部首先会遍历所有入口模块执行 markModuleAndImpureDependenciesAsExecuted(module); 将 module.isExecuted 修改为 true; 接着 if 语句判断是否存在 this.options.treeshake ，是则执行 module.include() 逻辑，否则执行 module.includeAllInBundle()。也就是将所有代码都打包输出。

当然，我们使用 rollup 打包的时候程序帮我们默认开启了 treeshake 。 因此我们看到 if 代码块内部的逻辑，首先定义了 treeshakingPass=1，并且执行过 do 语句之后 treeshakingPass 会执行 ++ 的操作，因此 module.includeAllExports(false) 的逻辑只会执行一次。do...while 语句表示 do 里面的逻辑至少会被执行一次。for (const module of this.modules) 的内部首先判断了 module.isExecuted 并且 module.info.moduleSideEffects !== 'no-treeshake' 才会执行 module.include() 逻辑。因为在执行 markModuleAndImpureDependenciesAsExecuted(module) 的时候就已经将 modulel.isExecuted 设置为 true 了。并且 module.info.moduleSideEffects 默认是一个对象。所以默认情况下会执行 module.include() 逻辑。

module.include 代码定义在 src/Module.ts 中：

```js
class Module {
  //...
  include(): void {
		//context => {"brokenFlow":0,"includedCallArguments":{},"includedLabels":{}}
		const context = createInclusionContext();
		if (this.ast!.shouldBeIncluded(context)) this.ast!.include(context, false);
	}
}
```

module.include 方法内部首先执行 const context = createInclusionContext() 会得到这么一个对象‘{"brokenFlow":0,"includedCallArguments":{},"includedLabels":{\}}’。接着判断 this.ast.shouldBeIncluded(context)为 true 才去执行 this.ast.include(context, false) 方法。

Node.shouldBeIncluded

```js
//src/ast/nodes/shared/Node.ts

class NodeBase extends ExpressionEntity implements ExpressionNode {
  //...
  shouldBeIncluded(context: InclusionContext): boolean {
    return this.included || (!context.brokenFlow && this.hasEffects(createHasEffectsContext()));
  }
  //...
}
```

这里的 shouldBeIncluded 方法内部 this.included 中的 this 就是 Program，默认值为 false。 context.brokenFlow 为 0，this.hasEffects(createHasEffectsContext()) 返回了 true。 我们继续看看 this.hasEffects(createHasEffectsContext()) 的逻辑。

createHasEffectsContext()

```js
//src/ast/ExecutionContext.ts

export function createHasEffectsContext(): HasEffectsContext {
  return {
    accessed: new PathTracker(),  //被访问过的实体会存放在这里
    assigned: new PathTracker(),  //被赋值调用过的实体会存放在这里
    brokenFlow: BROKEN_FLOW_NONE, //0
    called: new DiscriminatedPathTracker(), //被调用过的实体会存放到这里
    ignore: {
      breaks: false,
      continues: false,
      labels: new Set(),
      returnYield: false
    },
    includedLabels: new Set(),
    instantiated: new DiscriminatedPathTracker(), //实例
    replacedVariableInits: new Map()  
  };
}
```

hasEffects

```js
//src/ast/nodes/Program.ts

export default class Program extends NodeBase {
  //...
  hasEffects(context: HasEffectsContext): boolean {
    // 设置 hasCachedEffect 缓存
    if (this.hasCachedEffect) return true;
    for (const node of this.body) {
      if (node.hasEffects(context)) {
        return (this.hasCachedEffect = true);
      }
    }
    return false;
  }
  //...
}
```

查看 Program.hasEffeects 得知，原来最终得看 body 中所有的子节点中是否存在任一 node.hasEffects(context) 返回了 true。

我们总结下哪些 node.hasEffects 是直接能得到答案的：

- ArrowFunctionExpression：默认为 false
- AwaitExpression：默认为 true
- EmptyStatement：默认我 false
- ExportAllDeclaration：默认为 false
- ForOfStatement： 默认为 true
- ImportDeclaration：默认为 false
- ImportExpression：默认为 true
- MetaProperty：默认为 false
- TemplateElement：默认为 false
- ThrowStatement：默认为 true
- UnknownNode：默认为 true
