# generateModuleGraph

generateModuleGraph 方法的主要职责就是构建模块的“依赖图谱”。

在该方法的内部首先会调用 normalizeEntryModules(this.options.input) 方法将入口模块的 id 组成的数组通过包装加上一些 fileName、implicitlyLoadedAfter、name 等信息。请看如下示例：

```js
//转换前
// ['example/index.js']

// 通过 normalizeEntryModules 方法转换后的结果
// [{"fileName":null,"id":"example/index.js","implicitlyLoadedAfter":[],"name":null}]
```

经过上面的转换过程再调用 this.moduleLoader.addEntryModules 方法读取模块（文件）里的代码。然后得到 this.entryModules，和 this.implicitEntryModules。如果根据 input 的值未读取到任何模块信息，rollup 会报错提示“You must supply options.input to rollup”。意思就是你必须提供一个 input 选项。

如果 this.entryModules 存在模块信息，则进一步通过 module instanceof Module 判断这些模块是否是刚才创建的，是则执行 this.modules.push(module) 将模块保存起来。否则执行 this.externalModules.push(module) 逻辑。

```js
	private async generateModuleGraph(): Promise<void> {
		/**
		 * normalizeEntryModules(this.options.input) => '[{"fileName":null,"id":"example/index.js","implicitlyLoadedAfter":[],"name":null}]'
		 */
		({ entryModules: this.entryModules, implicitEntryModules: this.implicitEntryModules } =
			await this.moduleLoader.addEntryModules(normalizeEntryModules(this.options.input), true));
		if (this.entryModules.length === 0) {
			throw new Error('You must supply options.input to rollup');
		}
		for (const module of this.modulesById.values()) {
			if (module instanceof Module) {
				this.modules.push(module);
			} else {
				this.externalModules.push(module);
			}
		}
	}
```

接着继续深入 this.moduleLoader.addEntryModules 的方法，这个方法其实就是调用的 ModuleLoader.addEntryModules 方法。ModuleLoader 类定义在：src/ModuleLoader.ts

addEntryModules 方法接收两个参数：第一个参数是 unresolvedEntryModules，它是一个数组，保存着 module 信息。第二个参数是 isUserDefined，在刚才的方法调用中传入了 true，代表这个是用户定义的模块信息。addEntryModules 最终返回的是一个 Promise 对象，里面包含了 entryModules，implicitEntryModules，newEntryModules。

```js
export class ModuleLoader {
  //...
  async addEntryModules(
		unresolvedEntryModules: readonly UnresolvedModule[],
		isUserDefined: boolean
	): Promise<{
		entryModules: Module[];
		implicitEntryModules: Module[];
		newEntryModules: Module[];
	}> {
		const firstEntryModuleIndex = this.nextEntryModuleIndex;
		this.nextEntryModuleIndex += unresolvedEntryModules.length;
		const firstChunkNamePriority = this.nextChunkNamePriority;
		this.nextChunkNamePriority += unresolvedEntryModules.length;
		const newEntryModules = await this.extendLoadModulesPromise(
			Promise.all(
				unresolvedEntryModules.map(({ id, importer }) =>
					this.loadEntryModule(id, true, importer, null)
				)
			).then(entryModules => {
				// entryModules => [Module]
				for (const [index, entryModule] of entryModules.entries()) {
					entryModule.isUserDefinedEntryPoint =
						entryModule.isUserDefinedEntryPoint || isUserDefined;
					addChunkNamesToModule(
						entryModule,
						unresolvedEntryModules[index],
						isUserDefined,
						firstChunkNamePriority + index
					);
					const existingIndexedModule = this.indexedEntryModules.find(
						indexedModule => indexedModule.module === entryModule
					);
					if (!existingIndexedModule) {
						this.indexedEntryModules.push({
							index: firstEntryModuleIndex + index,
							module: entryModule
						});
					} else {
						existingIndexedModule.index = Math.min(
							existingIndexedModule.index,
							firstEntryModuleIndex + index
						);
					}
				}
				//排序入口模板
				this.indexedEntryModules.sort(({ index: indexA }, { index: indexB }) =>
					indexA > indexB ? 1 : -1
				);
				return entryModules;
			})
		);
		await this.awaitLoadModulesPromise();
		return {
			entryModules: this.indexedEntryModules.map(({ module }) => module),
			implicitEntryModules: [...this.implicitEntryModules],
			newEntryModules
		};
	}
  //...
}
```

我们深入函数内部分析：**unresolvedEntryModules 是一个数组，因为 rollup 支持多入口的配置。**接着调用 Promise.all(unresolvedEntryModules.map(({ id, importer }) => this.loadEntryModule(id, true, importer, null))) 将所有的入口模块通过调用 loadEntryModule 方法加载进来,然后得到 entryModules。

这段代码可能看起来不太容易明白。我在这里放一个示例图大家就清楚了：

<img src="../images/entryModules.png" width="600px" heigth="600px" />

拿到 entryModules 信息之后再对其循环取出对应的模块信息执行 this.indexedEntryModules.push({ index: firstEntryModuleIndex + index, module: entryModule }) 将入口模块进行了排序保存到 this.indexedEntryModules 中。再继续将 this.indexedEntryModules 进行排序。最后将 entryModules，implicitEntryModules，newEntryModules return 出去。

细心的同学可能会问，我传入的 options.input 是"example/index.js"，这个字符串路径是一个相对路径并不能读取到文件呢。
