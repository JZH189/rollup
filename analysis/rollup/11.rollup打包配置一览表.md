# rollup 打包配置一览表

# output 配置

### output.dir

- 类型：string
- 命令行参数：-d / --dir \<dirname>

该选项用于指定所有生成 chunk 文件所在的目录。如果生成多个 chunk，则此选项是必须的。否则，可以使用 file 选项代替。

### output.file

类型：string 命令行参数：-o / --file <filename>

该选项用于指定要写入的文件名。如果该选项生效，那么同时也会生成源码映射（sourcemap）文件。只有当生成的 chunk 不超过一个时，该选项才会生效。

### output.format

- 类型：string
- 命令行参数：-f / --format \<formatspecifier>

该选项用于指定生成 bundle 的格式。可以是以下**六种**之一：

1. amd - 异步模块定义，适用于 RequireJS 等模块加载器
2. cjs - CommonJS，适用于 Node 环境和其他打包工具（别名：commonjs）
3. es - 将 bundle 保留为 ES 模块文件，适用于其他打包工具以及支持 \<script type=module> 标签的浏览器（别名: esm，module）
4. iife - 自执行函数，适用于 \<script> 标签。（如果你要为你的应用创建 bundle，那么你很可能用它。）
5. umd - 通用模块定义，生成的包同时支持 amd、cjs 和 iife 三种格式
6. system - SystemJS 模块加载器的原生格式（别名: systemjs）

### output.globals

- 类型：{ [id: string]: string } | ((id: string) => string)
- 命令行参数：-g / --globals \<external-id: variableName, another-external-id: anotherVariableName,...>

该选项用于使用 id: variableName 键值对指定的、在 umd 或 iife 格式 bundle 中的外部依赖。下面就是一个外部依赖的例子：

```js
import $ from 'jquery';
```

在这个例子中，我们想要告诉 Rollup jquery 是外部依赖，并且 jquery 模块的 ID 为全局变量 $：

```js
// rollup.config.js
export default {
  ...,
  external: ['jquery'],
  output: {
    format: 'iife',
    name: 'MyBundle',
    globals: {
      jquery: '$'
    }
  }
};

/*
var MyBundle = (function ($) {
  // code goes here
}($));
*/
```

或者，我们也可以使用将外部依赖映射为全局变量的函数作为 output.globals 的值。

在作为命令行参数时，该选项的值应该是以逗号分隔的 id:variableName 键值对：

```bash

rollup -i src/main.js ... -g jquery: $, underscore: _

```

要告诉 Rollup 用全局变量替换本地文件，请使用系统绝对文件路径：

```js

// rollup.config.js
import path from 'path';
const externalId = path.resolve( __dirname, 'src/some-local-file-that-should-not-be-bundled.js' );

export default {
  ...,
  external: [externalId],
  output: {
    format: 'iife',
    name: 'MyBundle',
    globals: {
      [externalId]: 'globalVariable'
    }
  }
};

```

### output.name

- 类型：string
- 命令行: -n/--name <variableName>

该选项用于，在想要使用全局变量名来表示你的 bundle 时，输出格式必须指定为 iife 或 umd。同一个页面上的其他脚本可以通过这个变量名来访问你的 bundle 导出。

```js

// rollup.config.js
export default {
  ...,
  output: {
    file: 'bundle.js',
    format: 'iife',
    name: 'MyBundle'
  }
};

// var MyBundle = (function () {...
```

该选项也支持命名空间，即包含 . 的名字。最终生成 bundle 将包含命名空间所需要的设置。

```js
rollup -n "a.b.c"

/* ->
this.a = this.a || {};
this.a.b = this.a.b || {};
this.a.b.c = ...
*/
```

### output.plugins

- 类型：OutputPlugin | (OutputPlugin | void)[]

该选项用于指定输出插件，这是设置插件的唯一入口。另外，[Plugins](https://www.rollupjs.com/guide/plugin-development) 会告诉你如何写一个你自己的插件。对于从包中引入的插件，请记住要调用引入的函数（例如，应该使用 commonjs()，而不是 commonjs）。返回值为 Falsy 的插件将会被忽略，这样可以用于灵活启用和禁用插件。

请注意，并不是所有的插件都可以通过该选项使用。output.plugins 选项是受限的，例如，只有在 Rollup 的主分析阶段完成以后，在 bundle.generate() 或者 bundle.write() 阶段执行的 hooks 的插件才可以使用该选项。如果你是一个插件的作者，你可以查看 [output generation hooks](https://www.rollupjs.com/guide/big-list-of-options#output-generation-hooks) 了解更多关于 hooks 的使用方法。

以下是一个使用压缩插件的例子:

```js
// rollup.config.js
import { terser } from 'rollup-plugin-terser';

export default {
  input: 'main.js',
  output: [
    {
      file: 'bundle.js',
      format: 'es'
    },
    {
      file: 'bundle.min.js',
      format: 'es',
      plugins: [terser()]
    }
  ]
};
```

### plugins

- 类型：Plugin | (Plugin | void)[]

对于从包中引入的插件，请记住调用引入的函数（例如，应该使用 commonjs()，而不是 commonjs）。返回值为 Falsy 的插件将会被忽略，这样可以用于灵活启用和禁用插件。

```js
// rollup.config.js
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';

const isProduction = process.env.NODE_ENV === 'production';

export default (async () => ({
  input: 'main.js',
  plugins: [resolve(), commonjs(), isProduction && (await import('rollup-plugin-terser')).terser()],
  output: {
    file: 'bundle.js',
    format: 'cjs'
  }
}))();
```

（上述例子还演示了如何使用异步 IIFE 和动态引入来避免引入会使 Rollup 打包变慢的不必要的模块。）

# 进阶功能（Advanced functionality）

### cache

- 类型：RollupCache | false

该选项用于指定先前的 bundle 的缓存。当设置 cache 后，Rollup 只会对改变的部分进行重新分析，从而加速观察模式（watch mode）中的后续构建。如果将它设置为 false，则会阻止 bundle 生成缓存，还会导致插件的缓存失效。

```js
const rollup = require('rollup');
let cache;

async function buildWithCache() {
  const bundle = await rollup.rollup({
    cache // 如果 cache 值为 falsy，那么该选项会被忽略
    // ... 其他输入选项
  });
  cache = bundle.cache; // 保存之前构建的数据缓存
  return bundle;
}

buildWithCache()
  .then(bundle => {
    // ... do something with the bundle
  })
  .then(() => buildWithCache()) // 将会使用之前构建的缓存
  .then(bundle => {
    // ... do something with the bundle
  });
```

### onwarn

- 类型：(warning: RollupWarning, defaultHandler: (warning: string | RollupWarning) => void) => void;

该选项用于拦截警告消息。如果未使用该选项，警告消息就会去重并打印在控制台（console）。当命令行中使用 --silent 参数时，该选项是唯一能够获取警告通知的方法。

该选项是函数类型，接收两个输入参数：警告对象（warning object）和默认处理函数（default handler）。其中，警告对象至少包含 code 和 message 两个属性，用于处理不同类型的警告。另外，根据不同的警告类型，警告对象上会有其他的属性。

```js

// rollup.config.js
export default {
  ...,
  onwarn (warning, warn) {
    // 忽略指定类型的警告
    if (warning.code === 'UNUSED_EXTERNAL_IMPORT') return;

    // 抛出其他类型错误
    if (warning.code === 'NON_EXISTENT_EXPORT') throw new Error(warning.message);

    // 使用默认处理函数兜底
    warn(warning);
  }
};
```

很多警告还具有 loc 和 frame 属性，它们可以用来定位警告来源。

```js
// rollup.config.js
export default {
  ...,
  onwarn ({ loc, frame, message }) {
    if (loc) {
      console.warn(`${loc.file} (${loc.line}:${loc.column}) ${message}`);
      if (frame) console.warn(frame);
    } else {
      console.warn(message);
    }
  }
};
```

### output.assetFileNames

- 类型：string
- 命令行参数：--assetFileNames \<pattern>
- 默认值："assets/[name]-[hash][extname]"

该选项用于自定义构建结果中的静态文件名称。它支持以下占位符：

- [extname]：包含点的静态文件扩展名，例如：.css。
- [ext]：不包含点的文件扩展名，例如：css。
- [hash]：基于静态文件的名称和内容的哈希。
- [name]：静态文件的名称，不包含扩展名。正斜杆 / 可以用来划分文件到子目录。又见 output.chunkFileNames, output.entryFileNames。
