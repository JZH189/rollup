# sortModules

sortModules 主要做了两件事情：一个是排序模块,另一个就是绑定 node.variable，即绑定变量的引用信息。先看代码定义：src/Graph.ts

```js
export default class Graph {
  //...
  async build(): Promise<void> {
    //...
    await this.generateModuleGraph();
    this.sortModules();
    this.includeStatements();
  }

  private sortModules(): void {
		const { orderedModules, cyclePaths } = analyseModuleExecution(this.entryModules);
		for (const cyclePath of cyclePaths) {
			this.options.onwarn(errorCircularDependency(cyclePath));
		}
		this.modules = orderedModules;
		for (const module of this.modules) {
			//绑定变量的引用
			module.bindReferences();
		}
		//...
	}
  //...
}
```

sortModule 内部首先执行 analyseModuleExecution(this.entryModules) 。analyseModuleExecution 代码定义在：src/utils/executionOrder.ts

```js
function analyseModuleExecution(entryModules: readonly Module[]): {
	cyclePaths: string[][];
	orderedModules: Module[];
} {
	let nextExecIndex = 0;
	const cyclePaths: string[][] = [];
	const analysedModules = new Set<Module | ExternalModule>();
	const dynamicImports = new Set<Module>();
	const parents = new Map<Module | ExternalModule, Module | null>();
	const orderedModules: Module[] = [];

	const analyseModule = (module: Module | ExternalModule) => {
		if (module instanceof Module) {
      /**
       * 如果存在循环引入模块，例如 index.js 里面导入了 user.js, user.js 里面又导入了 index.js 则两者之间称为循环引用。
       * cyclePaths => [['c:\Users\**\Desktop\study\rollup-master\rollup\example\index.js', 'c:\Users\**\Desktop\study\rollup-master\rollup\example\user.js', 'c:\Users\**\Desktop\study\rollup-master\rollup\example\index.js']]
       */
			for (const dependency of module.dependencies) {
				if (parents.has(dependency)) {
					if (!analysedModules.has(dependency)) {
						cyclePaths.push(getCyclePath(dependency as Module, module, parents));
					}
					continue;
				}
				parents.set(dependency, module);
				analyseModule(dependency);
			}
			for (const dependency of module.implicitlyLoadedBefore) {
				dynamicImports.add(dependency);
			}
			for (const { resolution } of module.dynamicImports) {
				if (resolution instanceof Module) {
					dynamicImports.add(resolution);
				}
			}
			orderedModules.push(module);
		}

		module.execIndex = nextExecIndex++;
		analysedModules.add(module);
	};

	for (const currentEntry of entryModules) {
		if (!parents.has(currentEntry)) {
			parents.set(currentEntry, null);
			analyseModule(currentEntry);
		}
	}
  //分析动态导入模块
	for (const currentEntry of dynamicImports) {
		if (!parents.has(currentEntry)) {
			parents.set(currentEntry, null);
			analyseModule(currentEntry);
		}
	}

	return { cyclePaths, orderedModules };
}
```

analyseModuleExecution 方法内部首先会执行 for of 遍历 entryModules 对每个入口模块执行 analyseModule(currentEntry)。analyseModule 内部首先会判断传入的 module 是否为 rollup 创建的 module。如果是则对 module.dependencies 遍历，并对每个模块执行 analyseModule(dependency)，这样可以保证 orderedModules 里面的 module 排序的正确性。然后再对 dynamicImports 执行和 entryModules 一样的处理逻辑再次收集 orderedModules。最后将得到的 cyclePaths 和 orderedModules 返回。

通过代码分析可以得知，排序模块遵循的先后顺序为： dependencyModule > implicitlyLoadedBefore > dynamicImports。

分析完 analyseModuleExecution 的逻辑后我们再接着回到 sortModules 方法。sortModule 方法调用 analyseModuleExecution(this.entryModules) 拿到 orderedModules 和 cyclePaths。接着判断如果存在 cyclePaths 则会报警告 "Circular dependency"。再接着执行 this.modules = orderedModules 将排序好的模块信息保存到 this.modules。最后就是遍历 this.modules 执行 module.bindReferences()。

## module.bindReferences

module.bindReferences 其实就是绑定变量的引用信息。我们先找到对应的代码定义：src/Module.ts

```js
export default class Module {
	//...
bindReferences(): void {
		this.ast!.bind();
	}
}
```

bindReferences() 内部又执行了 this.ast.bind() 实际上执行的是 NodeBase.bind()。代码定义在 src/ast/nodes/shared/Node.ts

```js
class NodeBase {
//...
bind(): void {
		for (const key of this.keys) {
			const value = (this as GenericEsTreeNode)[key];
			if (Array.isArray(value)) {
				for (const child of value) {
					child?.bind();
				}
			} else if (value) {
				value.bind();
			}
		}
	}
	//...
}
```

bind 方法内部会对 this.keys 进行遍历操作，this.keys 实际上就是模块的 ast。
